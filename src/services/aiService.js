const axios = require('axios');
const pool = require('../database/connection');

class AIService {
  constructor() {
    this.apiUrl = process.env.HF_API_URL || 'https://api-inference.huggingface.co/models/google/gemma-3-27b-it';
    this.token = process.env.HF_TOKEN;
    this.isProcessing = false;
  }

  async processContent(contentType, contentId) {
    try {
      // Mark as processing
      await pool.query(
        'UPDATE ai_processing_queue SET status = $1 WHERE content_id = $2 AND content_type = $3',
        ['processing', contentId, contentType]
      );

      // Get content based on type
      let content = await this.getContent(contentType, contentId);
      if (!content) {
        throw new Error('Content not found');
      }

      // Generate AI analysis
      const analysis = await this.generateAnalysis(contentType, content);

      // Update content with AI analysis
      await this.updateContentWithAI(contentType, contentId, analysis);

      // Mark as completed
      await pool.query(
        'UPDATE ai_processing_queue SET status = $1, result = $2, processed_at = CURRENT_TIMESTAMP WHERE content_id = $3 AND content_type = $4',
        ['completed', JSON.stringify(analysis), contentId, contentType]
      );

      return analysis;
    } catch (error) {
      console.error('AI processing error:', error);
      
      // Mark as failed
      await pool.query(
        'UPDATE ai_processing_queue SET status = $1, error_message = $2, processed_at = CURRENT_TIMESTAMP WHERE content_id = $3 AND content_type = $4',
        ['failed', error.message, contentId, contentType]
      );

      throw error;
    }
  }

  async getContent(contentType, contentId) {
    let query;
    switch (contentType) {
      case 'dua':
        query = 'SELECT title, purpose, arabic_text, english_meaning, transliteration, native_meaning, source_reference FROM duas WHERE id = $1';
        break;
      case 'blog':
        query = 'SELECT title, content FROM blogs WHERE id = $1';
        break;
      case 'question':
        query = 'SELECT title, content FROM questions WHERE id = $1';
        break;
      case 'answer':
        query = 'SELECT content FROM answers WHERE id = $1';
        break;
      default:
        throw new Error('Invalid content type');
    }

    const result = await pool.query(query, [contentId]);
    return result.rows[0];
  }

  async generateAnalysis(contentType, content) {
    const prompt = this.buildPrompt(contentType, content);
    
    console.log('ЁЯУЭ AI Service Prompt being sent:');
    console.log('=' .repeat(80));
    console.log(prompt);
    console.log('=' .repeat(80));
    
    try {
      const response = await axios.post(
        this.apiUrl,
        {
          inputs: prompt,
          parameters: {
            max_new_tokens: 800,
            temperature: 0.6,
            top_p: 0.9,
            top_k: 50,
            repetition_penalty: 1.1,
            return_full_text: false,
            do_sample: true
          }
        },
        {
          headers: {
            'Authorization': `Bearer ${this.token}`,
            'Content-Type': 'application/json'
          },
          timeout: 60000 // Increased timeout for larger model
        }
      );

      console.log('ЁЯдЦ AI Service Raw Response:');
      console.log('=' .repeat(80));
      console.log(JSON.stringify(response.data, null, 2));
      console.log('=' .repeat(80));

      return this.parseAIResponse(response.data);
    } catch (error) {
      console.error('Hugging Face API error:', error.response?.data || error.message);
      throw new Error('AI service temporarily unavailable');
    }
  }

  buildPrompt(contentType, content) {
    const basePrompt = `Content to analyze:
Title: ${content.title || 'Not specified'}
Purpose: ${content.purpose || 'Not specified'}
Arabic Text: ${content.arabic_text || 'Not specified'}
English Meaning: ${content.english_meaning || 'Not specified'}
Transliteration: ${content.transliteration || 'Not specified'}
Native Meaning: ${content.native_meaning || 'Not specified'}
Source Reference: ${content.source_reference || 'N/A'}

Check the contents for any issues and provide a summary of the content correction and suggestions.
- Do not use md styling only use with plain text.
- Show the output as json format. Each correction will be as a array element.
- Proive bangla and english for the correction and suggestions.
- If ther is no correction need the correction array will be empty . 
- Here is a sample output struture 

{
    "analysis": {
      "title": " ржЬрж╛рж╣рж╛ржирзНржирж╛ржо ржерзЗржХрзЗ ржорзБржХрзНрждрж┐",
      "purpose": "Not specified",
      "arabic_text": " ╪з┘Д┘Д┘С┘О┘З┘П┘Е┘О┘С ╪г┘О╪м┘Р╪▒┘Т┘Ж┘Р┘Й ┘Е┘Р",
      "english_meaning": "O Allah! Save me from the fire of Hell.",
      "transliteration": "ржЖрж▓рзНрж▓рж╛рж╣рзБржорзНржорж╛ ржЖржЬрж┐рж░ржирж┐ ржорж┐ржирж╛ржи ржирж╛рж░ред",
      "native_meaning": "рж╣рзЗ ржЖрж▓рзНрж▓рж╛рж╣! ржЖржорж╛ржХрзЗ",
      "source_reference": "N/A"
    },
    "corrections": [
      {
        "field": "title",
        "issue_english": "Descriptive, not standard for a du'a.",
        "issue_bangla": "ржмрж░рзНржгржиржорзВрж▓ржХ, ржПржХржЯрж┐ ржжрзБ'ржпрж╝рж╛рж░ ржЬржирзНржп ржЖржжрж░рзНрж╢ ржиржпрж╝ред",
        "suggestion_english": "Du'a for Protection from Hellfire",
        "suggestion_bangla": "ржЬрж╛рж╣рж╛ржирзНржирж╛ржо ржерзЗржХрзЗ рж╕рзБрж░ржХрзНрж╖рж╛рж░ ржЬржирзНржп ржжрзБ'ржЖ"
      }
    ],
    "summary": {
      "english": "The provided content contains several inaccuracies, primarily due to an incomplete Arabic text. Corrections include completing the Arabic and Bengali text, refining the transliteration, providing a more accurate English meaning, suggesting a better title, and emphasizing the need to specify a purpose and source reference. These changes improve the content's accuracy, clarity, and usefulness.",
      "bangla": "ржкрзНрж░ржжрждрзНржд ржЕржВрж╢рзЗ ржмрзЗрж╢ ржХрж┐ржЫрзБ ржнрзБрж▓ рж░ржпрж╝рзЗржЫрзЗ, ржпрж╛рж░ ржкрзНрж░ржзрж╛ржи ржХрж╛рж░ржг рж╣рж▓ ржПржХржЯрж┐ ржЕрж╕ржорзНржкрзВрж░рзНржг ржЖрж░ржмрж┐ ржкрж╛ржаред рж╕ржВрж╢рзЛржзржиржЧрзБрж▓рж┐рж░ ржоржзрзНржпрзЗ ржЖрж░ржмрж┐ ржПржмржВ ржмрж╛ржВрж▓рж╛ ржкрж╛ржа рж╕ржорзНржкрзВрж░рзНржг ржХрж░рж╛, ржкрзНрж░рждрж┐ржмрж░рзНржгрзАржХрж░ржг ржкрж░рж┐ржорж╛рж░рзНржЬржи ржХрж░рж╛, ржЖрж░ржУ рж╕ржарж┐ржХ ржЗржВрж░рзЗржЬрж┐ ржЕрж░рзНрже ржкрзНрж░ржжрж╛ржи ржХрж░рж╛, ржПржХржЯрж┐ ржнрж╛рж▓ рж╢рж┐рж░рзЛржирж╛ржо ржкрзНрж░рж╕рзНрждрж╛ржм ржХрж░рж╛ ржПржмржВ ржЙржжрзНржжрзЗрж╢рзНржп ржУ ржЙрзОрж╕ ржЙрж▓рзНрж▓рзЗржЦ ржХрж░рж╛рж░ ржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝рждрж╛рж░ ржЙржкрж░ ржЬрзЛрж░ ржжрзЗржУржпрж╝рж╛ ржЕржирзНрждрж░рзНржнрзБржХрзНрждред ржПржЗ ржкрж░рж┐ржмрж░рзНрждржиржЧрзБрж▓рж┐ рж╕рж╛ржоржЧрзНрж░рзАрж░ ржирж┐рж░рзНржнрзБрж▓рждрж╛, рж╕рзНржкрж╖рзНржЯрждрж╛ ржПржмржВ ржЙржкржпрзЛржЧрж┐рждрж╛ ржмрзГржжрзНржзрж┐ ржХрж░рзЗред"
    }
  }

output:`;

    return basePrompt;
  }

  parseAIResponse(response) {
    try {
      console.log('ЁЯФН Raw AI Response:', JSON.stringify(response, null, 2));
      
      // Handle different response formats from Hugging Face
      let text = '';
      if (Array.isArray(response)) {
        text = response[0]?.generated_text || '';
      } else if (response.generated_text) {
        text = response.generated_text;
      } else if (typeof response === 'string') {
        text = response;
      }

      console.log('ЁЯУЭ Extracted text:', text);

      // Try to parse as JSON first
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        console.log('ЁЯОп JSON match found:', jsonMatch[0]);
        try {
          const jsonResponse = JSON.parse(jsonMatch[0]);
          console.log('тЬЕ Parsed JSON:', JSON.stringify(jsonResponse, null, 2));
          
          // Handle the working example format
          if (jsonResponse.analysis && jsonResponse.corrections && jsonResponse.summary) {
            console.log('ЁЯЗзЁЯЗй Working example format detected');
            const result = {
              summary: {
                english: jsonResponse.summary.english || 'Summary not provided',
                bangla: jsonResponse.summary.bangla || 'рж╕рж╛рж░рж╛ржВрж╢ ржкрзНрж░ржжрж╛ржи ржХрж░рж╛ рж╣ржпрж╝ржирж┐'
              },
              corrections: Array.isArray(jsonResponse.corrections) ? 
                jsonResponse.corrections.map(correction => 
                  typeof correction === 'object' ? {
                    field: correction.field || 'unknown',
                    issue_english: correction.issue_english || '',
                    issue_bangla: correction.issue_bangla || '',
                    suggestion_english: correction.suggestion_english || '',
                    suggestion_bangla: correction.suggestion_bangla || ''
                  } : correction
                ) : 
                [jsonResponse.corrections || 'ржкрж░рж╛ржорж░рзНрж╢ ржкрзНрж░ржжрж╛ржи ржХрж░рж╛ рж╣ржпрж╝ржирж┐'],
              authenticity: {
                english: 'Content analysis completed',
                bangla: 'ржмрж┐рж╖ржпрж╝ржмрж╕рзНрждрзБ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг рж╕ржорзНржкржирзНржи рж╣ржпрж╝рзЗржЫрзЗ'
              },
              confidence: 0.8
            };
            console.log('ЁЯОЙ Returning working example result:', JSON.stringify(result, null, 2));
            return result;
          }
          
          // Fallback to simple format
          console.log('ЁЯЗзЁЯЗй Simple format detected');
          const result = {
            summary: jsonResponse.summary || 'рж╕рж╛рж░рж╛ржВрж╢ ржкрзНрж░ржжрж╛ржи ржХрж░рж╛ рж╣ржпрж╝ржирж┐',
            corrections: Array.isArray(jsonResponse.corrections) ? jsonResponse.corrections : [jsonResponse.corrections || 'ржкрж░рж╛ржорж░рзНрж╢ ржкрзНрж░ржжрж╛ржи ржХрж░рж╛ рж╣ржпрж╝ржирж┐'],
            authenticity: jsonResponse.authenticity || 'рж╕рждрзНржпрждрж╛ ржорзВрж▓рзНржпрж╛ржпрж╝ржи ржкрзНрж░ржжрж╛ржи ржХрж░рж╛ рж╣ржпрж╝ржирж┐',
            confidence: jsonResponse.confidence || 0.8
          };
          console.log('ЁЯОЙ Returning simple result:', JSON.stringify(result, null, 2));
          return result;
        } catch (jsonError) {
          console.log('тЭМ JSON parsing failed:', jsonError.message);
          console.log('ЁЯУЭ Falling back to text parsing');
        }
      } else {
        console.log('тЭМ No JSON match found in text');
      }

      // Fallback to text parsing if JSON parsing fails
      const lines = text.split('\n').filter(line => line.trim());
      
      let summary = '';
      let corrections = '';
      let authenticity = '';

      let currentSection = '';
      for (const line of lines) {
        const trimmedLine = line.trim();
        const lowerLine = trimmedLine.toLowerCase();
        
        // Check for section headers
        if (lowerLine.includes('summary:') || lowerLine.includes('1. summary') || lowerLine.includes('summary')) {
          currentSection = 'summary';
          summary += trimmedLine.replace(/^(summary:|1\.\s*summary|summary)\s*/i, '').trim() + ' ';
        } else if (lowerLine.includes('corrections:') || lowerLine.includes('2. corrections') || lowerLine.includes('correction')) {
          currentSection = 'corrections';
          corrections += trimmedLine.replace(/^(corrections:|2\.\s*corrections|correction)\s*/i, '').trim() + ' ';
        } else if (lowerLine.includes('authenticity:') || lowerLine.includes('3. authenticity') || lowerLine.includes('authenticity')) {
          currentSection = 'authenticity';
          authenticity += trimmedLine.replace(/^(authenticity:|3\.\s*authenticity|authenticity)\s*/i, '').trim() + ' ';
        } else if (currentSection && trimmedLine) {
          // Continue adding to current section
          switch (currentSection) {
            case 'summary':
              summary += trimmedLine + ' ';
              break;
            case 'corrections':
              corrections += trimmedLine + ' ';
              break;
            case 'authenticity':
              authenticity += trimmedLine + ' ';
              break;
          }
        }
      }

      // Clean up and ensure we have meaningful content
      const cleanSummary = summary.trim() || 'AI analysis completed - content appears to be Islamic in nature';
      const cleanCorrections = corrections.trim() || 'No specific corrections suggested - content appears authentic';
      const cleanAuthenticity = authenticity.trim() || 'Content appears to be Islamic in nature and authentic';

      return {
        summary: cleanSummary,
        corrections: [cleanCorrections],
        authenticity: cleanAuthenticity,
        confidence: 0.8
      };
    } catch (error) {
      console.error('Error parsing AI response:', error);
      return {
        summary: 'AI ржжрзНржмрж╛рж░рж╛ ржмрж┐рж╢рзНрж▓рзЗрж╖рж┐ржд ржмрж┐рж╖ржпрж╝ржмрж╕рзНрждрзБ - ржмрж┐рж╖ржпрж╝ржмрж╕рзНрждрзБ ржЗрж╕рж▓рж╛ржорзА ржкрзНрж░ржХрзГрждрж┐рж░ ржмрж▓рзЗ ржоржирзЗ рж╣ржЪрзНржЫрзЗ',
        corrections: ['ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржкрж╛рж░рзНрж╕ ржХрж░рждрзЗ ржЕржХрзНрж╖ржо - ржорзНржпрж╛ржирзБржпрж╝рж╛рж▓ ржкрж░рзНржпрж╛рж▓рзЛржЪржирж╛ рж╕рзБржкрж╛рж░рж┐рж╢ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ'],
        authenticity: 'ржмрж┐рж╖ржпрж╝ржмрж╕рзНрждрзБ ржЗрж╕рж▓рж╛ржорзА ржкрзНрж░ржХрзГрждрж┐рж░ ржмрж▓рзЗ ржоржирзЗ рж╣ржЪрзНржЫрзЗ - ржпрж╛ржЪрж╛ржЗ рж╕рзБржкрж╛рж░рж┐рж╢ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ',
        confidence: 0.0
      };
    }
  }

  async updateContentWithAI(contentType, contentId, analysis) {
    let query;
    switch (contentType) {
      case 'dua':
        query = 'UPDATE duas SET ai_summary = $1, ai_corrections = $2 WHERE id = $3';
        break;
      case 'blog':
        query = 'UPDATE blogs SET ai_summary = $1 WHERE id = $2';
        break;
      case 'question':
        query = 'UPDATE questions SET ai_summary = $1 WHERE id = $2';
        break;
      case 'answer':
        query = 'UPDATE answers SET ai_summary = $1 WHERE id = $2';
        break;
      default:
        throw new Error('Invalid content type for update');
    }

    const params = contentType === 'dua' 
      ? [analysis.summary, analysis.corrections, contentId]
      : [analysis.summary, contentId];

    await pool.query(query, params);
  }

  async processQueue() {
    if (this.isProcessing) {
      return;
    }

    this.isProcessing = true;

    try {
      // Get next pending item
      const result = await pool.query(
        'SELECT * FROM ai_processing_queue WHERE status = $1 ORDER BY created_at ASC LIMIT 1',
        ['pending']
      );

      if (result.rows.length > 0) {
        const item = result.rows[0];
        await this.processContent(item.content_type, item.content_id);
      }
    } catch (error) {
      console.error('Queue processing error:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  startQueueProcessor() {
    // Process queue every 30 seconds
    setInterval(() => {
      this.processQueue();
    }, 30000);

    console.log('AI queue processor started');
  }
}

module.exports = new AIService();
